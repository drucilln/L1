package main

import "fmt"

func main() {
	arr := []int{10, 22, 33, 71, 42, 74, 7, 34, 87, 86, 81, 58, 71, 78, 27, 38}
	arr = quickSort(arr, 0, len(arr)-1)
	fmt.Println(arr)
}

// Функция quickSort реализует алгоритм быстрой сортировки
// arr - массив для сортировки
// l - левый индекс подмассива
// r - правый индекс подмассива
func quickSort(arr []int, l int, r int) []int {
	if l < r { //Если левый индекс меньше правого,
		// значит, в подмассиве больше одного элемента, и имеет смысл продолжать сортировку.
		q := partition(arr, l, r) // Разделяем массив и получаем индекс разделения q
		quickSort(arr, l, q)      // Рекурсивно сортируем левую часть массива
		quickSort(arr, q+1, r)    // Рекурсивно сортируем правую часть массива
	}
	return arr
}

// Функция partition разделяет массив на две части относительно опорного элемента
// Возвращает индекс разделения
func partition(arr []int, l int, r int) int {
	v := arr[(l+r)/2] // Выбираем опорный элемент как средний элемент подмассива
	i := l            // Начало подмассива
	j := r            // Конец подмассива

	// Бесконечный цикл, который будет прерван внутренне
	for {
		for arr[i] < v { // Двигаем i вправо, пока элемент arr[i] меньше опорного элемента v
			i++
		}
		for arr[j] > v { // Двигаем j влево, пока элемент arr[j] больше опорного элемента v
			j--
		}
		if i >= j { // Если индексы встретились или пересеклись, возвращаем индекс j как точку разделения подмассива
			return j
		}
		arr[i], arr[j] = arr[j], arr[i] // Если i < j, меняем местами элементы arr[i] и arr[j]
		// Сдвигаем индексы для продолжения прохода
		i++
		j--
	}
}
